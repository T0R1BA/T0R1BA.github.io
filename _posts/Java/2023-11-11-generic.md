---
title:  "Generic"
excerpt: "generic"
categories: Java
tag: [generic]
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
---

# 제네릭이란?
{: .notice--warning .text-center}

Type을 사용자가 외부에서 주입(injection) 시켜 정의하는 문법으로 자바 5부터 도입 되었습니다. 클래스와 인터페이스, 메서드를 정의할 때 타입을 파라미터로 사용할 수 있도록 합니다. 제네릭을 사용하면 컴파일 시에 타입 안정성을 확보할 수 있고, 코드의 재사용성을 높이며, 코드의 가독성을 향상시킬 수 있습니다.

# 제네릭의 주요 특징
{: .notice--warning .text-center}

## 타입 안정성(Type Safety)
{: .notice--success .text-center}

제네릭을 사용하면 컴파일 시에 컴파일러가 타입 체크를 수행하여 타입 불일치 오류를 방지할 수 있습니다. 이로써 런타임에 발생할 수 있는 형변환 오류를 사전에 방지할 수 있습니다. 따라서 instanceof, casting을 사용할 필요가 없어집니다.

```java
// 제네릭을 사용하지 않은 경우
List list = new ArrayList();
list.add("문자열");

Integer value = (Integer) list.get(0); // 런타임 에러 발생

if (list.get(0) instanceof Integer) Integer value = (Integer) list.get(0); // instanceof, casting을 사용해야 함

// 제네릭을 사용한 경우
List<String> genericList = new ArrayList<>();
genericList.add("문자열");
String str = genericList.get(0); // 컴파일 에러 방지
```

## 코드 재사용성
{: .notice--success .text-center}

제네릭을 사용하면 다양한 데이터 타입에 대해 동일한 코드를 사용할 수 있습니다. 이는 코드의 재사용성을 높여줍니다.

```java
// 제네릭을 사용한 클래스
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// 다양한 데이터 타입에 대해 사용 가능
Box<Integer> intBox = new Box<>();
Box<String> strBox = new Box<>();

```

## 컬렉션 프레임워크의 활용
{: .notice--success .text-center}

자바의 컬렉션 프레임워크는 제네릭을 통해 다양한 타입의 요소를 담을 수 있습니다. 예를 들어, ArrayList<E>, HashMap<K, V> 등이 제네릭을 활용한 대표적인 컬렉션 클래스입니다.

```java
List<String> stringList = new ArrayList<>();
Map<Integer, String> intToStringMap = new HashMap<>();
```

## 와일드카드(Wildcards)
{: .notice--success .text-center}

제네릭에서는 와일드카드(?)를 사용하여 불특정한 타입을 나타낼 수 있습니다. 와일드카드는 주로 메소드 매개변수나 제네릭 클래스의 변수 선언 등에서 사용됩니다.

```java
public static void printList(List<?> list) {
    for (Object obj : list) {
        System.out.print(obj + " ");
    }
}
```

# 클래스, 객체 예시
{: .notice--warning .text-center}

```java
// T(Type의 약자)는 약속된 문자로 다른 문자열로 대체 가능하며 여러 개 정의가 가능
public class Pair<T, U> {
    private T key;
    private U value;

    public Pair(T key, U value) {
        this.key = key;
        this.value = value;
    }

    public T getKey() {
        return key;
    }

    public U getValue() {
        return value;
    }

    public void setKey(T key) {
        this.key = key;
    }

    public void setValue(U value) {
        this.value = value;
    }

    public static void main(String[] args) {
        // Integer와 String을 갖는 Pair 객체
        Pair<Integer, String> integerStringPair = new Pair<>(1, "One");

        System.out.println("Key: " + integerStringPair.getKey());    // Key: 1
        System.out.println("Value: " + integerStringPair.getValue());// Value: One

        // Double과 Boolean을 갖는 Pair 객체
        Pair<Double, Boolean> doubleBooleanPair = new Pair<>(3.14, true);

        System.out.println("Key: " + doubleBooleanPair.getKey());      // Key: 3.14
        System.out.println("Value: " + doubleBooleanPair.getValue());  // Value: true
    }
}
```

# 메서드 예시
{: .notice--warning .text-center}

```java
public class GenericMethodExample {
    
    // 제네릭 메서드
    public <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        GenericMethodExample example = new GenericMethodExample();

        // 다양한 데이터 타입의 배열을 출력
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] strArray = {"One", "Two", "Three", "Four", "Five"};

        example.printArray(intArray); // Integer 배열 출력
        example.printArray(strArray); // String 배열 출력
    }
}
```

# 상속 예시
{: .notice--warning .text-center}

```java
// 부모 클래스
class Box<T> {
    private T content;

    public Box(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}

// 자식 클래스가 두 개의 제네릭 타입을 갖는 경우
class PairBox<T, U> extends Box<T> {
    private U secondContent;

    public PairBox(T content, U secondContent) {
        super(content);
        this.secondContent = secondContent;
    }

    public U getSecondContent() {
        return secondContent;
    }

    public void setSecondContent(U secondContent) {
        this.secondContent = secondContent;
    }
}

public class MultipleGenericInheritanceExample {
    public static void main(String[] args) {
        // 부모 클래스의 제네릭 타입을 유지하면서 두 번째 타입 추가
        PairBox<String, Integer> pairBox = new PairBox<>("Hello, Generics!", 42);

        System.out.println("Content: " + pairBox.getContent());               // Content: Hello, Generics!
        System.out.println("Second Content: " + pairBox.getSecondContent());  // Second Content: 42
    }
}
```

# 다형성 예시
{: .notice--warning .text-center}

```java
public class DataHolder<T> {
    private T data;

    public DataHolder(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public static void main(String[] args) {
        // DataHolder<Number>를 사용하는 데이터 홀더
        DataHolder<Number> numberDataHolder = new DataHolder<>(42);

        // 데이터 읽기
        Number data = numberDataHolder.getData();
        System.out.println("Data: " + data);

        // 다른 Number 하위 타입으로 업데이트
        numberDataHolder.setData(3.14);
        data = numberDataHolder.getData();
        System.out.println("Updated Data: " + data);

        // 다른 Number 하위 타입으로 업데이트
        numberDataHolder.setData(100L);
        data = numberDataHolder.getData();
        System.out.println("Updated Data: " + data);
    }
}
```

위의 예시에서 `DataHolder<Number>`는 Number 타입의 데이터만을 받을 수 있습니다. 따라서 Number의 하위 클래스인 Integer, Double, Long 등을 저장하고 읽을 수 있지만, 상위 클래스인 Object나 다른 Number의 상위 클래스는 저장할 수 없습니다. 

```java
public class DataHolder<T> {
    private T data;

    public DataHolder(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public static void main(String[] args) {
        // DataHolder<? super Number>를 사용하는 데이터 홀더
        DataHolder<? super Number> numberDataHolder = new DataHolder<>(42);

        // 데이터 읽기
        Object data = numberDataHolder.getData();
        System.out.println("Data: " + data);

        // 다른 Number 하위 타입으로 업데이트
        numberDataHolder.setData(3.14);
        data = numberDataHolder.getData();
        System.out.println("Updated Data: " + data);

        // 다른 Number 하위 타입으로 업데이트
        numberDataHolder.setData(100L);
        data = numberDataHolder.getData();
        System.out.println("Updated Data: " + data);

        // Number의 상위 타입인 Object로 업데이트
        numberDataHolder.setData("Hello");
        data = numberDataHolder.getData();
        System.out.println("Updated Data: " + data);
    }
}
```

위의 코드에서 numberDataHolder는 `DataHolder<? super Number>` 타입으로 선언되었습니다. 이렇게 하면 numberDataHolder에는 Number의 상위 클래스인 Object로부터 파생된 모든 타입의 데이터를 저장할 수 있습니다. 따라서 getData()로 읽을 때 반환되는 데이터는 Object 타입입니다.

이를 통해 DataHolder<? super Number>를 사용하면 Number의 하위 타입 뿐만 아니라 Number의 상위 타입까지 다룰 수 있는 유연성을 얻을 수 있습니다.

```java
public class DataHolder<T> {
    private T data;

    public DataHolder(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public static void main(String[] args) {
        // DataHolder<? extends Number>를 사용하는 데이터 홀더
        DataHolder<? extends Number> numberDataHolder = new DataHolder<>(42);

        // 데이터 읽기
        Number data = numberDataHolder.getData();
        System.out.println("Data: " + data);

        // 다른 Number 하위 타입으로 업데이트 - 컴파일 에러
        // numberDataHolder.setData(3.14); // 에러 발생

        // 다른 Number 하위 타입으로 업데이트 - 컴파일 에러
        // numberDataHolder.setData(100L); // 에러 발생
    }
}
```

위의 코드에서 numberDataHolder에는 Number의 어떤 하위 타입의 데이터도 저장할 수 있습니다. 그러나 데이터를 읽을 때는 그 하위 타입을 정확하게 알 수 없기 때문에 일반적으로 Number로 읽게 됩니다. 데이터를 업데이트할 때는 컴파일 에러가 발생할 수 있습니다. 이는 `DataHolder<? extends Number>`가 특정 타입의 하위 타입에 제한되기 때문입니다.