---
title:  "List"
excerpt: "list"
categories: Java
tag: [list, collection]
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
---

# List란?
{: .notice--warning .text-center}

Java에서 List는 인터페이스로 정의된 컬렉션 프레임워크의 일부입니다. List는 순서가 있는 데이터의 컬렉션을 나타내며, 중복된 요소를 허용합니다. List는 배열과 유사하지만 크기가 동적으로 조절될 수 있으며, 다양한 유용한 메서드를 제공하여 데이터를 조작하고 관리할 수 있습니다.

# List의 계층 구조
{: .notice--warning .text-center}

```lua
java.util.List
    |
    +-- java.util.ArrayList
    |
    +-- java.util.LinkedList
    |
    +-- java.util.Vector
        |
        +-- java.util.Stack
```

# ArrayList, LinkedList, Vector의 차이
{: .notice--warning .text-center}

1) ArrayList:<br>
&nbsp;- 내부적으로 동적 배열을 사용하여 요소를 저장합니다.
&nbsp;- 요소에 대한 빠른 랜덤 액세스가 가능합니다. 인덱스를 사용하여 요소에 직접 접근할 수 있습니다.
&nbsp;- 요소를 추가하거나 제거할 때, 다른 요소들을 한 칸씩 이동시켜야 할 수 있습니다. 따라서 추가/삭제 연산이 많은 경우에는 성능이 저하될 수 있습니다.
&nbsp;- ArrayList는 스레드 동기화가 되어있지 않습니다. 따라서 멀티스레드 환경에서 안전하지 않습니다.

2) LinkedList:<br>
&nbsp;- 이중 연결 리스트로 구현되어 있습니다. 각 요소는 자신의 이전과 다음 요소에 대한 참조를 가지고 있습니다.
&nbsp;- 요소를 추가하거나 제거할 때 다른 요소를 이동시킬 필요가 없어, 추가/삭제 연산이 빠릅니다.
&nbsp;- 랜덤 액세스가 느리며, 특정 인덱스의 요소에 접근하기 위해 전체를 순회해야 합니다.
&nbsp;- LinkedList도 스레드 동기화가 되어있지 않습니다.

3) Vector:<br>
&nbsp;- 오래된 자료구조로, 동적 배열을 기반으로 합니다. ArrayList와 유사하지만 스레드 동기화가 되어 있습니다.
&nbsp;- 스레드에 안전하다는 특징 때문에, 멀티스레드 환경에서 사용할 때 유용합니다. 그러나 성능 면에서는 다소 느릴 수 있습니다.
&nbsp;- 요소 추가/삭제 시에도 다른 요소를 이동시켜야 할 수 있어, 성능이 저하될 수 있습니다.

요약하면, ArrayList는 랜덤 액세스가 빠르지만 추가/삭제가 느리고, LinkedList는 추가/삭제가 빠르지만 랜덤 액세스가 느립니다. Vector는 스레드에 안전하지만 성능 면에서는 다소 느릴 수 있습니다.

# List 사용 예시
{: .notice--warning .text-center}

## 선언 및 초기화
{: .notice--success .text-center}

```java
List<String> arrayList1 = new ArrayList<>(); // 기본 생성자를 사용하여 빈 ArrayList 생성
List<String> linkedList1 = new LinkedList<>(); // 기본 생성자를 사용하여 빈 LinkedList 생성
List<String> arrayList2 = new ArrayList<>(10); // 초기 용량(capacity)를 지정하여 ArrayList 생성
List<String> arrayList3 = new ArrayList<String>(); // 1.7 이전 문법
// 컬렉션의 이름이 생략되지 않은 형태 : 컬렉션의 고유 메서드를 사용할 때
ArrayList<String> arrayList4 = new ArrayList<>();
LinkedList<String> linkedList2 = new LinkedList<>();
```

## 배열에서 List로 변환하기
{: .notice--success .text-center}

```java
String[] array = new String[10];

// 1) Arrays.asList() 활용
List<String> list1 = new ArrayList<>(Arrays.asList(array));
List<String> list2 = Arrays.asList(array); // 읽기 전용으로 추가, 수정, 삭제가 불가능 (fixed-size)
		
// 2) 고전적인 알고리즘 활용1
List<String> list3 = new ArrayList<>();
// Advanced for loop
for(String element : array) {
	list3.add(element);
}
		
// 3) 고전적인 알고리즘 활용2
List<String> list4 = new ArrayList<>();
List<String> list5 = new ArrayList<>();
// index for loop
for(int i = 0; i < array.length; i++) {
    list4.add(array[i]);
	list5.add(i, array[i]); // index를 지정하여 추가
}
```

## 순회
{: .notice--success .text-center}

```java
// 1)Enhanced for문
for(String e : list) {
    System.out.println(e);
}

// 2)index for문
for(int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}

// 3)foreach 람다 표현식
list.forEach((e) -> System.out.println(e));
```

## add, addAll
{: .notice--success .text-center}

```java
list.add("data"); // 데이터 삽입
list.add(i, "data"); // index에 데이터 삽입, 기존 값들은 뒤로 밀림
list.addAll(list); // 기존 값들을 유지한 채 인자로 넣은 컬렉션의 데이터 복제 삽입
```

## size
{: .notice--success .text-center}

```java
List<String> list = new ArrayList<>(10); // 초기 용량 설정

list.size(); // 리스트의 크기 반환, 현재 크기는 0이기 때문에 0 반환
```

## get
{: .notice--success .text-center}

```java
list.get(i); // 리스트의 인덱스에 해당하는 값 반환
```

## contains
{: .notice--success .text-center}

```java
list.contains(object); // 특정한 객체가 List에 존재하는지 확인
```

## remove, clear
{: .notice--success .text-center}

```java
list.remove(i); // 리스트의 인덱스에 해당하는 값 삭제
list.remove(object); // 리스트의 해당 객체 삭제
list.clear(); // 리스트의 모든 데이터 삭제
```