---
title: "[Foundation Level] 제 1장. 테스팅의 기초"
excerpt: "Foundation Level Chapter.1 Fundamentals of Testing"
categories: istqb
tag: [ISTQB, Foundation Level]
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
---

<details>
<summary>Keywords</summary>
<div markdown="1">

- 커버리지(coverage)

- 디버깅(debugging)

- 결함(defect)

- 오류(error)

- 장애(failure)

- 품질(quality)

- 품질 보증(quality assurance)

- 근본 원인(root cause)

- 테스트 분석(test analysis)

- 테스트 베이시스(test basis)

- 테스트 케이스(test case)

- 테스트 완료(test completion)

- 테스트 컨디션(test condition)

- 테스트 제어(test control)

- 테스트 데이터(test data)

- 테스트 설계(test design)

- 테스트 실행(test execution)

- 테스트 구현(test implementation)

- 테스트 모니터링(test monitoring)

- 테스트 대상(test object)

- 테스트 목적(test objective)

- 테스트 오라클(test oracle)

- 테스트 계획(test planning)

- 테스트 절차(test procedure)

- 테스트 프로세스(test process)

- 테스트 스위트(test suite)

- 테스팅(testing)

- 테스트웨어(testware)

- 추적성(traceability)

- 밸리데이션(확인 validation)

- 베리피케이션(검증 verification)

</div>
</details>

# 1.1 테스팅이란 무엇인가? What is Testing?
{: .notice--warning .text-center}

소프트웨어 테스팅은 소프트웨어의 품질을 평가하고, 운영 중 소프트웨어 장애의 발생 가능성을 줄이는 하나의 방법이다.<br>
테스팅에 대해 많이 오해하는 것 중 하나는 테스팅이 단지 소프트웨어를 실행하고 결과를 확인하는 테스트 수행에 국한된다고 생각하는 것이다.<br> 소프트웨어 테스팅이란 다양한 활동을 포함하는 프로세스이며 테스트 실행(결과 확인 포함)은 그 많은 활동 중 하나일 뿐이다.<br>
테스트 프로세스는 테스트 계획, 분석, 설계, 테스트 구현, 테스트 진행 상황 및 결과 보고, 테스트 대상 품질 평가 등 많은 활동을 포함한다.<br>
테스팅 활동에는 테스트 대상 컴포넌트나 시스템을 실행하는 것도 있다. 이런 테스팅을 동적 테스팅이라 부른다.<br>
반면 테스트 대상 컴포넌트나 시스템을 실행하지 않는 테스팅도 있다. 이런 테스팅은 정적 테스팅이라 부른다.<br>
따라서 요구사항, 사용자 스토리, 소스 코드와 같은 작업 산출물에 대한 리뷰 역시 테스팅에 포함된다.
테스팅에 대한 또 다른 오해는 테스팅이 요구사항, 사용자 스토리, 그 외 기타 명세의 베리피케이션(검증 verification)에만 국한된 활동이라는 것이다.<br>
시스템이 주어진 명세를 충족하는지 확인하는 것이 테스팅에 포함되긴 하지만, 시스템이 운영 환경에서 사용자 또는 기타 이해관계자의 요구를 만족시키는지를 확인하는 밸리데이션(확인 validation) 또한 테스팅에 포함된다.<br>
테스팅 활동은 수명주기 모델에 따라 다르게 계획하고 수행한다.

## 1.1.1 테스팅의 일반적인 목적 (Typical Objectives of Testing)
{: .notice--success}

일반적인 프로젝트에서 테스팅은 다음과 같은 목적을 가질 수 있다:<br>
● 요구사항, 사용자스토리, 설계, 소스 코드 등과 같은 작업 산출물 평가에 의한 결함 예방<br>
● 명시된 모든 요구사항이 충족됐는지 검증<br>
● 테스트 대상의 완성 여부 확인과 사용자와 기타 이해관계자의 기대치 대로 동작하는지의 확인<br>
● 테스트 대상의 품질 수준에 대한 자신감 획득<br>
● 부적절한 소프트웨어 품질의 리스크 레벨 감소로 장애와 결함을 발견<br>
● 이해관계자가 테스트 대상의 품질 수준을 결정하는 데 필요한 충분한 정보 제공<br>
● 계약/법률/규제 요구사항이나 표준의 준수 및 테스트 대상이 이러한 요구사항이나 표준을 준수하는지 확인

테스팅의 목적은 테스트하고 있는 컴포넌트나 시스템의 정황 즉, 현재의 테스트 레벨과 사용하는 소프트웨어 개발 수명주기 모델 등에 따라 달라질 수 있다. 목적이 정황에 따라 달라지는 예는 다음과 같다:<br>
● 컴포넌트 테스팅의 목적 중 하나는 내재되어 있는 결함을 최대한 조기에 가능한 많이 식별하고 수정하는 것일 수 있다. 또 다른 목적은 코드 커버리지를 높이는 것일 수도 있다.<br>
● 인수 테스팅의 주요 목적 중 하나는 시스템이 기대한 대로 동작하는지, 또 요구사항을 충족하는지 확인하는 것일 수 있다. 또 다른 목적은 특정 시점에 시스템을 배포하는 것에 대한 리스크 정보를 이해관계자에게 제공하는 것일 수 있다.

## 1.1.2 테스팅과 디버깅 (Testing and Debugging)
{: .notice--success}

테스팅과 디버깅은 다르다. 테스트를 실행하면 소프트웨어 결함으로 인한 장애를 찾아낼 수 있으며, 디버깅은 그런 장애의 원인을 찾고 분석해서 수정하는 개발 활동이다. 이후 실행되는 확인 테스팅에서 결함을 제대로 수정했는지 확인한다.<br>
테스터가 초기 테스트와 마지막 확인 테스트를 담당하고 개발자는 디버깅 관련 컴포넌트 및 컴포넌트 통합 테스팅 (지속적 통합)을 수행한다.<br>
반면, 애자일 개발 및 기타 소프트웨어 수명주기 모델에서는 테스터가 디버깅과 컴포넌트 테스팅에 관여하기도 한다.<br>
소프트웨어 테스팅 개념에 대한 추가적인 정보는 ISO 표준(ISO/IEC/IEEE 29119-1)에서 찾을 수 있다.

# 1.2 테스팅이 왜 필요한가? Why is Testing Necessary?
{: .notice--warning .text-center}

컴포넌트, 시스템 및 관련 문서에 대한 철저한 테스팅은 운영 중 장애 발생 가능성을 줄이는 데 도움이 된다.<br>
결함을 발견하고 또 발견된 결함을 수정하는 것은 컴포넌트나 시스템의 품질에 기여하는 것이다. 또한, 소프트웨어 테스팅이 계약/법적 요구사항이나 특정 산업 표준을 만족시키기 위해 필요할 수도 있다.

## 1.2.1 성공을 위한 테스팅의 기여 (Testing’s Contributions to Success)
{: .notice--success}

컴퓨터의 역사에서 소프트웨어와 시스템이 운영을 위해 배포된 후로, 결함으로 장애가 발생하거나 이해관계자의 요구를 충족시키지 못하는 상황은 늘 있었다. 하지만 적절한 테스트 기법을 적절한 테스트 전문성을 가지고 적절한 테스트 레벨과 개발 수명주기 단계에 적용하면, 소프트웨어와 시스템이 그런 문제를 안고 배포되는 경우를 줄일 수 있다. 대표적인 예로는:<br>
● 테스터를 요구사항 리뷰 혹은 사용자 스토리 개선에 참여시키면 해당 작업 산출물에서 결함을 발견할 수 있다. 요구사항 결함을 식별하고 제거하면 잘못된 혹은 테스트할 수 없는 기능이 개발되는 리스크를 줄일 수 있다.<br>
● 시스템을 설계하는 동안 테스터가 시스템 설계자와 적극적으로 협업할 경우, 설계와 그것을 어떻게 테스트해야 하는지에 대해 서로 좀 더 깊이 있게 이해하게 된다. 이렇게 이해도가 올라가면 기능 설계에 결함이 유입되는 리스크가 줄어들게 되고, 필요한 테스트를 좀 더 일찍 식별할 수 있다.<br>
● 코드를 개발하는 동안 테스터가 개발자와 적극적으로 협업할 경우, 코드와 그것을 어떻게 테스트해야 하는지에 대해 서로 좀 더 깊이 있게 이해하게 된다. 이렇게 이해도가 높아지면 코드와 테스트에서의 결함 발생 리스크가 줄어든다.<br>
● 테스터가 릴리스 전에 소프트웨어를 확인하고 검증하면, 그러지 않았을 경우 놓쳤을 수 있는 장애를
발견하고 그 장애의 원인인 결함을 제거(즉, 디버깅)하는 데 도움을 줄 수 있다. 이렇게 함으로써 소프트웨어가 이해관계자의 필요와 요구사항을 충족시킬 가능성을 높일 수 있다.<br>
이런 경우뿐만 아니라 정의된 테스트 목적을 충족하는 것은 소프트웨어 개발과 유지보수 전반의 성공 확률을 높여준다.

## 1.2.2 품질 보증과 테스팅 (Quality Assurance and Testing)
{: .notice--success}

일반적으로 사람들이 품질 보증(QA, Quality Assurance)과 테스팅을 혼용해서 사용하는 경우가 많은데 어느 정도 연관성이 있지만 품질 보증과 테스팅은 다른 개념이다. 둘 다 좀 더 포괄적인 개념인 품질 관리(quality management)에 속한다.<br>
품질 관리에는 품질 측면에서 조직이 나아가야 하는 방향을 제시하고 제어하는 모든 활동이 포함된다. 품질 관리는 또한 품질 보증과 품질 제어를 포함한 여러 가지 활동을 포함한다.<br>
일반적으로 품질 보증은 적절한 품질 수준을 달성했는지 확신을 얻기 위해 적절한 프로세스를 준수하도록 하는 것에 초점을 두고 있다. 프로세스를 따를 경우, 해당 프로세스를 바탕으로 생성되는 작업 산출물의 품질은 더 월등한 경우가 많으며, 높은 작업 산출물 품질은 결함 예방에 도움이 된다. 또한, 결함의 원인을 찾아서 제거하기 위한 근본 원인 분석(root cause analysis)의 활용과 회고 회의(retrospective meetings)의 결과를 적절하게 적용해서 프로세스를 개선하는 것은 효과적인 품질 보증에 매우 중요한 사항들이다.<br>
품질 제어에도 적합한 품질 수준을 달성하기 위한 다양한 활동이 있으며, 테스트 활동도 여기에 포함된다. 테스트 활동은 전반적인 소프트웨어 개발 및 유지보수 프로세스의 일부이다.<br>
품질 보증에서는 전반적인 프로세스의 올바른 수행 여부에 관심을 가지기 때문에 올바른 테스팅의 적용에도 관심을 가진다. 테스팅은 품질을 높이는 데 다양한 방법으로 기여한다.

## 1.2.3 오류, 결함, 장애 (Errors, Defects, and Failures)
{: .notice--success}

사람은 프로그램 코드 또는 기타 작업 산출물을 작성하면서 결함(결점, 버그)을 발생시키는 오류(실수)를 범할 수 있다. 특정 작업 산출물 내 결함의 원인이 되는 오류는 연관된 다른 작업 산출물의 결함의 원인이 되는 또 다른 오류의 계기가 될 수 있다. 예를 들어, 요구사항을 도출하면서 범해진 오류는 요구사항 결함이 되며, 이런 요구사항 결함은 프로그램 작성 시 오류를 일으켜 결국 코드 결함의 원인이 된다.<br>
코드의 결함이 실행되면 장애를 일으킬 수 있지만 반드시 그런 것은 아니다. 예를 들어, 결함 중 일부는 발생 가능성이 없거나 매우 낮아서 특수한 입력이나 사전조건이 충족돼야 장애를 일으킬 수 있다.<br>
대표적인 오류 발생 원인은 다음과 같다:<br>
● 시간적인 압박<br>
● 사람의 실수<br>
● 경험이 적거나 기술이 부족한 프로젝트 참여자<br>
● 요구사항과 설계 등에 대한 프로젝트 참여자 간의 의사소통 문제<br>
● 코드, 설계, 아키텍처의 복잡성, 해결해야 하는 근본 문제, 사용하는 기술의 복잡도<br>
● 시스템 내/외부 인터페이스에 대한 이해 부족, 특히 내/외부 인터페이스 수가 많은 경우<br>
● 새롭고 익숙하지 않은 기술

장애는 코드 결함뿐만 아니라 환경 조건으로 인해 발생할 수도 있다. 예를 들어, 방사능, 전자기장, 환경 오염 등은 펌웨어 결함의 원인이 되거나 하드웨어 상태를 변화시킴으로써 소프트웨어 실행에 영향을 줄 수 있다.<br>
테스트 결과가 기대한 것과 다르다고 해서 무조건 장애가 있다고 볼 수는 없다. 테스트 실행 방식의 오류나 테스트 데이터, 테스트 환경, 기타 테스트웨어에 결함이 있는 경우, 또는 그 외 다양한 이유로 거짓양성(false positive)이 발생할 수 있다. 비슷한 오류나 결함이 거짓음성(false negative)의 원인이 되는 반대의 경우도 발생할 수 있다. 거짓음성은 테스트가 발견했어야 할 결함을 발견하지 못하는 경우이며, 거짓양성은 결함으로 보고됐지만 실제 결함이 아닌 경우를 말한다.

## 1.2.4 결함, 근본 원인, 결과 (Defects, Root Causes and Effects)
{: .notice--success}

결함의 근본 원인은 해당 결함을 만들어낸 최초의 행동이나 조건을 말한다. 결함을 분석함으로써 근본 원인을 찾을 수 있으며, 차후 유사한 결함의 발생 가능성을 낮출 수 있다. 가장 근본적인 원인을 분석하고 여기에 집중하기 때문에, 이를 기반으로 이루어지는 프로세스 개선은 이후 발생하는 결함 수를 상당 부분 줄여준다.<br>
예를 들어, 단 한 줄의 잘못된 코드로 인한 이자 지급 오류는 소비자 불만을 초래한다. 제품 소유자가 이자 계산법을 잘못 이해해서 작성한 애매모호한 사용자 스토리를 기반으로 코드가 잘못 작성되었다. 대부분의 결함이 이자 계산식에 존재하며 해당 결함들의 근본 원인 역시 비슷한 오해로 인한 것이라면, 차후 유사한 결함의 발생 가능성을 낮추기 위해 제품 소유자에게 이자 계산에 대한 교육을 제공할 수 있다.<br>
앞의 예제에서의 결과는 소비자 불만이며 장애는 잘못된 이자 지급이다. 결함은 코드에 포함된 잘못된 계산식이며, 그것의 원인이 되는 최초 결함은 사용자 스토리의 모호성이다. 최초 결함의 근본 원인은 제품 소유자의 지식 부족이었으며, 그 결과로 제품 소유자가 사용자 스토리를 작성할 때 오류를 범했다고 볼 수 있다. 근본 원인 분석 프로세스는 ISTQB-CTFL-TM 및 ISTQB-CTFL-ITP 에서 다루고 있다.

# 1.3 테스팅의 7 가지 원리
{: .notice--warning .text-center}

# 1.4 테스트 프로세스
{: .notice--warning .text-center}

## 1.4.1 정황에 따른 테스트 프로세스
{: .notice--success}

## 1.4.2 테스트 활동과 작업
{: .notice--success}

## 1.4.3 테스트 작업 산출물
{: .notice--success}

## 1.4.4 테스트 베이시스와 테스트 작업 산출물 간의 추적성
{: .notice--success}

# 1.5 테스팅의 심리학
{: .notice--warning .text-center}

## 1.5.1 인간 심리학과 테스팅
{: .notice--success}

## 1.5.2 테스터와 개발자의 사고방식
{: .notice--success}

[자료출처](http://www.kstqb.org/board_skin/board_list.asp?page=1&bbs_code=4&etc=ISTQB){: .btn .btn--warning}