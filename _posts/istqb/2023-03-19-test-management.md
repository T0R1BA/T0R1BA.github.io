---
title: "[Foundation Level] 제 5장. 테스트 관리"
excerpt: "Foundation Level Chapter.5 Test Management"
categories: istqb
tag: [ISTQB, Foundation Level]
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
---

# 5.1 테스트 조직 (Test Organization)
{: .notice--warning .text-center}

## 5.1.1 독립적인 테스팅 (Independent Testing)
{: .notice--success}

<span style="color:green">(K2) 독립적 테스트의 장단점을 설명할 수 있다.</span>

테스팅 작업은 특정 테스팅 역할을 부여 받은 사람이나 다른 역할을 하는 사람도 수행할 수 있다 (예: 고객). 저자와 테스터가 가지는 인지편향(1.5 절 참조)의 차이 때문에 일정 수준의 독립성은 테스터가 결함을 더 효과적으로 찾게 해 준다. 그러나 독립성이 친숙함을 대체할 수 없으며 개발자도 자신이 작성한 코드에서 많은 결함을 효율적으로 찾아낼 수 있다.

테스팅의 독립성 수준은 다음과 같다 (낮은 수준에서 높은 수준까지):
- 독립적인 테스터 없음: 유일하게 개발자가 자신의 코드를 직접 테스트하는 형태
- 개발팀이나 프로젝트팀에 속한 독립적인 개발자나 테스터: 개발자가 동료의 제품을 테스트하는 형태도 포함
- 조직 내 독립적 테스트팀이나 그룹이 프로젝트 관리자나 상위 관리자에게 직접 보고
- 비즈니스 조직 또는 사용자 커뮤니티 소속이거나 사용성, 보안성, 성능, 준수성(regulatory/compliance), 이식성 등 특정 테스트 분야를 전문으로 하는 독립적인 테스터
- 현장(in-house) 또는 현장 외(outsourcing)에서 일하는 조직 외부의 독립적인 테스터

대부분의 프로젝트에서 보통 여러 테스트 레벨을 두고 그 중 일부는 독립적인 테스터가 담당하도록 하는 것이 최적이다. 개발자는 자신의 작업 산출물의 품질을 일정 수준으로 유지하기 위해 테스팅(특히 하위 레벨 테스팅)에 참여해야 한다.<br>
테스팅의 독립성을 어떻게 구현할지는 사용 중인 소프트웨어 개발 수명주기 모델에 따라 다르다. 예를 들어 애자일 개발에서는 테스터가 개발팀의 일부로 속할 수 있다. 애자일 방법론을 사용하는 일부 조직에서는 이런 테스터가 보다 큰 독립 테스트팀의 일부로 간주되기도 한다. 또 이런 조직에서는 제품 책임자가 각 반복주기(iteration) 말미에 인수 테스팅을 수행함으로써 사용자 스토리를 검증할 수 있다.

테스트 독립성의 잠재적 이점은 다음과 같다:
- 독립적인 테스터는 그들이 가지고 있는 다양한 배경, 기술적인 관점, 성향이 달라 개발자와는 다른 유형의 장애를 찾아낼 수 있다.
- 독립적인 테스터는 이해관계자가 시스템 명세를 정의하고 구현하면서 만든 가정(assumptions)에 대해 확인하고 이의를 제기하고 틀렸음을 입증할 수 있다.
- 벤더(vendor)의 독립 테스터는 테스트할 시스템을 고용한 회사의 (정치적) 압박 없이 똑바로 그리고 객관적으로 보고할 수 있다.

테스트 독립성의 잠재적 단점은 다음과 같다:
- 개발팀과의 고립으로 협업이 어려울 수 있고, 개발팀에게 피드백 전달이 늦어지고, 개발팀과 적대적인 관계가 형성될 수 있다.
- 개발자가 품질에 대한 책임감을 잃을 수 있다.
- 독립적인 테스터가 병목 현상의 장본인으로 비쳐질 수 있다.
- 독립적인 테스터는 중요한 정보(예: 테스트 대상에 대한 정보)를 전달받지 못할 수 있다.

테스트 독립성의 단점은 피하면서 그것이 가져오는 이점을 성공적으로 취하고 있는 조직도 많다.

## 5.1.2 테스트 관리자 및 테스터의 역할 (Tasks of a Test Manager and Tester)
{: .notice--success}

<span style="color:green">(K1) 테스트 관리자와 테스터의 역할을 식별할 수 있다.</span>

이 실러버스에서는 테스트 역할 두 가지 즉, 테스트 관리자와 테스터를 다룬다. 두 역할담당자의 활동과 업무는 프로젝트와 제품의 정황, 담당자의 역량, 조직 상황에 따라 달라진다.<br>
테스트 관리자의 업무는 테스트 프로세스에 대한 전반적인 책임과 테스트 활동을 성공적으로 이끄는 것이다. 테스트 관리자는 전문 테스트 관리자, 프로젝트 관리자, 개발 관리자, 품질 보증 관리자 역할을 맡을 수 있다. 규모가 큰 프로젝트나 조직인 경우 몇 개 테스트팀이 테스트 관리자, 테스트 코치, 테스트 코디네이터에게 보고하고, 각 팀은 테스트 리더나 리드 테스터(lead tester)가 책임진다.

일반적으로 테스트 관리자의 역할과 업무는 다음과 같다:
- 조직의 테스트 정책과 테스트 전략을 개발하고 리뷰
- 정황을 고려한 테스트 활동과 테스트 목적과 리스크 이해를 바탕으로 테스트 활동을 계획. 예를 들어, 테스트 접근법 선택, 테스트 추정(테스트 시간, 노력, 비용), 리소스 획득, 테스트 레벨과 테스트 주기 정의, 결함 관리 등이 계획에 포함될 수 있다.
- 테스트 계획서 작성과 업데이트
- 프로젝트 관리자, 제품 책임자, 기타 관계자와 테스트 계획 관련 협의
- 통합 계획 등과 같은 다른 프로젝트 활동과 테스팅 관점 공유
- 테스트 분석, 설계, 구현, 실행 활동을 개시하고, 테스트 진행과 결과를 모니터링하며 종료 조건(또는 종료 조건 정의)의 상태를 점검하고 테스트 완료 활동을 촉진
- 수집한 정보를 바탕으로 테스트 진행 상황 보고서와 테스트 요약 보고서 작성과 배포
- 테스트 결과와 진행 상황(테스트 진행 상황 보고서나 이미 완료된 다른 테스트 프로젝트의 테스트 요약 보고서에서 문서화된)에 따라 계획을 조정하고 테스트 제어에 필요한 모든 조치를 취함
- 결함 관리 시스템과 테스트웨어에 적합한 형상 관리 체제 구축 지원
- 테스트 진척 상황 측정과 테스팅 및 제품 품질 평가를 위한 적절한 메트릭 도입
- 테스트 프로세스 지원용 도구 선택과 구현 지원. 예를 들자면, 도구 선택 예산(경우에 따라 구입이나 지원 비용까지)에 대한 권고, 파일럿 프로젝트에 시간과 노력 할당, 도구 사용에 대한 지속적인 지원 제공 등
- 테스트 환경 구축에 관한 결정
- 조직에 테스터, 테스트팀, 테스트 활동을 홍보하고 지지를 요청
- 테스터의 역량과 경력 개발 (예: 교육계획, 성과평가, 코칭 등)

테스트 관리자의 역할은 소프트웨어 개발 수명주기의 영향을 받는다. 예를 들어, 애자일 개발에서 애자일팀은 위에서 언급한 일부 역할을 수행한다. 특히, 팀 내에서 매일 이루어지는 테스팅 관련 작업이 그러하며 팀에 속한 테스터가 수행하는 경우가 많다. 여러 팀에 걸쳐 있거나 전체 조직 또는 인력 관리와 관련한 일부 직무는 개발팀에 속하지 않은 테스트 관리자가 수행하기도 한다. 이런 테스트 관리자를 테스트 코치라고도 한다.<br>
테스트 프로세스 관리에 대한 추가 정보는 Black 2009 에서 찾을 수 있다.

일반적으로 테스터의 역할과 업무는 다음과 같다:
- 테스트 계획을 리뷰하고 계획 작성에 참여
- 요구사항, 사용자 스토리와 인수 조건, 명세, 모델(즉, 테스트 베이시스)의 테스트 용이성을 분석, 리뷰, 평가
- 테스트 컨디션을 식별 및 기록하고, 테스트 케이스, 테스트 컨디션, 테스트 베이시스 간의 추적성 설정
- 테스트 환경을 설계, 구축, 검증하고 필요한 경우 시스템 관리자, 네트워크 관리자와 협업
- 테스트 케이스와 테스트 프로시저를 설계 및 구현
- 테스트 데이터를 준비하고 획득
- 상세 테스트 실행 일정 수립
- 테스트를 실행하고 결과를 평가해, 기대 결과와 차이 기록
- 테스트 프로세스에 적합한 도구 사용
- 필요한 경우 테스트 자동화 (개발자나 테스트 자동화 전문가의 도움을 받을 수 있음)
- 수행 효율성, 신뢰성, 사용성, 보안성, 호환성, 이식성과 같은 비기능 품질 특성 평가
- 테스트 산출물 리뷰

테스트 분석, 테스트 설계, 특정 테스트 유형, 테스트 자동화에 관련해 일하는 사람은 각자의 역할에 전문가일 수 있다. 제품과 프로젝트의 리스크나 선택한 소프트웨어 개발 수명주기 모델에 따라 테스트 레벨별로 테스터의 역할이 다를 수 있다. 예를 들어, 컴포넌트 테스팅 레벨과 컴포넌트 통합 테스팅 레벨에서는 개발자가 테스터의 역할을 수행한다. 인수 테스트 레벨에서는 테스터 역할을 주로 비즈니스 분석가, 해당 분야 전문가나 사용자가 수행한다. 시스템 테스트 레벨과 시스템 통합 테스트 레벨에서는 주로 독립적인 테스트팀이 테스터의 역할을 담당한다. 운영 인수 테스트 레벨에서는 운영이나 시스템 관리 담당자가 테스터의 역할을 하는 경우가 많다.

# 5.2 테스트 계획과 추정 (Test Planning and Estimation)
{: .notice--warning .text-center}

## 5.2.1 테스트 계획의 목적과 내용 (Purpose and Content of a Test Plan)
{: .notice--success}

<span style="color:green">(K2) 테스트 계획의 목적과 내용을 요약할 수 있다.</span>

테스트 계획은 개발 및 유지보수 프로젝트의 테스트 활동에 대한 전반적인 내용을 담고 있다. 계획에 영향을 주는 요소로는 조직의 테스트 정책과 테스트 전략, 사용하는 개발 수명주기 및 방법(2.1 절 참조), 테스팅의 범위, 목적, 리스크, 제약, 심각도, 테스트 용이성, 자원의 가용성 등이 있다.<br>
프로젝트와 테스트 계획 작업을 진행함에 따라 더 많은 정보를 알게 되고 테스트 계획에 더 많은 세부 정보를 추가할 수 있다. 테스트 계획 활동은 제품의 수명주기 전반에 걸쳐 이루어지는 지속적인 활동이다 (제품의 수명주기는 프로젝트 범위를 넘어서 유지보수 단계까지 포함할 수 있다). 테스트 활동의 피드백으로 리스크의 변화를 인지하고 테스트 계획을 수정해야 한다. 계획은 마스터 테스트 계획의 일부로 작성하거나 시스템 테스팅, 인수 테스팅과 같은 테스트 레벨별 또는 사용성 테스팅, 성능 테스팅과 같은 테스트 유형별 테스트 계획으로 나눠서 작성할 수도 있다. 테스트 계획에는 다음과 같은 활동이 있고 이 중 일부는 테스트 계획서에 기록할 수 있다.
- 테스팅의 범위 정의, 목적, 리스크 결정
- 전반적인 테스팅 접근법 정의
- 테스트 활동을 소프트웨어 수명주기 활동에 통합하고 조정
- 테스트 대상 다양한 테스트 활동에 필요한 인력과 기타자원, 테스트 활동 수행 방법 결정
- 테스트 분석, 설계, 구현, 실행, 평가 활동의 일정 조정. 일정은 특정 날짜(예: 순차적 개발에서)나 반복주기 단위(예: 반복적 개발)로 편성할 수 있다.
- 테스트 모니터링과 제어에 사용할 메트릭 선정
- 테스트 활동 예산 결정
- 테스트 문서의 구조와 상세화 정도 정의 (예를 들어, 템플릿이나 예제 문서를 제공함으로써)

테스트 계획에 들어가는 내용은 다양하며 위에 나열한 외의 내용도 추가할 수 있다. 테스트 계획 구조와 테스트 계획의 예제는 ISO 표준(ISO/IEC/IEEE 29119-3)을 참고하라.

## 5.2.2 테스트 전략과 테스트 접근법 (Test Strategy and Test Approach)
{: .notice--success}

<span style="color:green">(K2) 여러 테스트 전략을 구별할 수 있다.</span>

테스트 전략은 테스트 프로세스의 일반적인 모습을 반영한다. 주로 제품이나 조직 수준에서 작성된다. 대표적인 테스트 전략 유형에는 다음과 같은 것들이 있다:
- **분석적 (Analytiacl)**: 특정 요소(예: 요구사항이나 리스크)에 대한 분석을 기반으로 한 테스트 전략. <u>리스크 수준에 따라 테스트를 설계하고 우선순위를 결정하는 리스크 기반 테스팅이 분석적 접근법의 예이다.</u>
- **모델 기반 (Model-Based)**: 이러한 유형의 테스트 전략에서 테스트는 요구되는 제품의 특정 측면에 대한 모델을 기반으로 만들어진다. 특정 측면에는 기능, 비즈니스 프로세스, 내부 구조, 비기능 특성(예: 신뢰성) 등이 있다. 모델에는 비즈니스 프로세스 모델, 상태 모델, 신뢰성 성장 모델 등이 있다.
- **방법론적 (Methodical)**: 이 테스트 전략은 사전에 정의한 테스트 셋이나 테스트 컨디션을 체계적으로 사용하는 데 의존한다. 예를 들어, 보편적이고 발생 가능성이 높은 장애 분류, 주요 품질 특성 목록, 모바일 애플리케이션이나 웹페이지에 대한 전사 룩앤필(look-and-feel) 표준 등이 있다.
- **프로세스 준수 ((Process-compliant), 또는 표준 준수(standard-compliant))**: 이 테스트 전략은 외부 규정이나 표준을 기반으로 테스트를 분석, 설계, 구현한다. 예를 들어, 특정 산업 표준에서 제시하는 규정이나 표준, 프로세스의 문서화, 테스트 베이시스의 엄격한 식별과 사용, 조직이 강제하거나 조직에 강요된 모든 프로세스나 표준을 기반으로 한다.
- **전문가 조언 ((Directive), 또는 자문(consultative))**: 이 테스트 전략은 주로 이해관계자, 비즈니스 도메인 전문가, 기술 전문가 등의 조언, 지도, 지시를 바탕으로 이루어진다. 이 사람들은 외부 테스트팀이나 외부 조직 소속일 수 있다.
- **리그레션-기피 (Regression-averse)**: 기존 기능에 대한 리그레션 테스트 기피를 목표로 한다. 이 테스트 전략에는 기존 테스트웨어(특히 테스트 케이스와 테스트 데이터)의 재사용, 리그레션 테스트 자동화 확대, 테스트 스위트 표준화가 포함된다.
- **반응적 (Reactive)**: 지금까지 소개한 사전 계획에 따라 실행하는 테스트 전략과는 달리 테스트 대상 컴포넌트나 시스템에 따라 대응하고 테스트 실행 중 발생하는 이벤트에 따라 반응적으로 수행하는 테스트 접근법이다. 이전 테스트 결과에서 얻은 지식을 바탕으로 테스트를 설계하고 구현하며 즉각 테스트를 실행할 수 있다. 탐색적 테스팅이 반응적 전략에서 일반적으로 사용하는 기법이다.

앞서 나열한 테스트 전략의 일부를 조합해 적절한 테스트 전략을 만든다. 예를 들어 분석적 전략인 리스크 기반 테스팅을 반응적 전략인 탐색적 테스팅과 조합할 수 있다; 서로 다른 접근법을 조합해 적용했을 때 각 접근법은 서로를 보완하며 더 효과적으로 테스팅을 수행할 수 있게 한다.<br>
테스트 전략은 테스트 프로세스를 종합해 개괄적으로 설명하는 반면, 테스트 접근법은 특정 프로젝트나 릴리스용으로 테스트 전략을 조정(tailoring)한 것이다. 테스트 접근법은 테스트 기법, 테스트 레벨, 테스트 유형을 선택하는 출발점이고, 시작 조건과 종료 조건(시작 조건과 종료 조건은 준비의 정의와 완료의 정의라고 부르기도 함)을 정의하는 출발점이다. 프로젝트의 복잡도와 목표, 개발하는 제품 유형, 제품 리스크 평가에 관한 결정을 기반으로 테스트 전략을 조정한다. 테스트 접근법은 정황(context)을 기반으로 선택하고 리스크, 안전 사항, 사용 가능한 자원과 역량, 기술, 시스템 특성(예: 맞춤형 개발 vs 상용 소프트웨어), 테스트 목적과 규정 같은 요소를 고려한다.

## 5.2.3 시작 조건과 종료 조건 (준비의 정의와 완료의 정의) Entry Criteria and Exit Criteria (Definition of Ready and Definition of Done)
{: .notice--success}

<span style="color:green">(K2) 시작 조건과 종료 조건에 대한 예제를 들 수 있다.</span>

소프트웨어 품질과 테스팅을 효과적으로 통제하려면 특정 테스트 활동의 시작 시점과 완료 시점에 대한 조건을 정의해 놓는 것이 좋다. 시작 조건(애자일 개발에서는 준비의 정의라고 하는 경우가 많음)은 특정 테스트 활동을 시작하기 위해 정의한 사전 조건이다. 시작 조건을 충족하지 못하면 해당 활동을 수행하기 더 어렵고 더 많은 시간을 필요로 하며 더 많은 비용이 들고 리스크에 노출될 가능성이 더 높아진다. 종료 조건(애자일 개발에서는 완료의 정의라고 부르는 경우가 많음)은 특정 테스트 레벨이나 테스트 세트가 끝났음을 선언하기 위해 만족해야 할 조건을 정의한다. 각 테스트 레벨과 테스트 유형의 시작과 종료 조건을 정의해야 하고 이는 테스트 목적에 따라 달라진다.

일반적인 시작 조건은 다음과 같다:
- 테스트 가능한 요구사항, 사용자 스토리나 모델(예: 모델 기반 테스트 전략을 따르는 경우)의 가용 여부
- 이전 테스트 레벨의 종료 조건을 충족한 테스트 항목의 가용 여부
- 테스트 환경 가용 여부
- 필요한 테스트 도구 가용 여부
- 테스트 데이터와 기타 필요한 자원의 가용 여부

일반적인 종료 조건은 다음과 같다:
- 계획한 테스트 실행 완료
- 정의한 커버리지 수준 (예: 요구사항, 사용자 스토리, 인수 조건, 리스크, 코드 등의 커버리지)의 도달
- 해결하지 못한 결함 수가 합의된 수보다 적음
- 추정 잔존 결함의 수가 충분히 적음
- 신뢰성, 수행 효율성, 사용성, 보안성, 기타 관련된 품질 특성의 수준이 원하는 수준에 도달

종료 조건을 충족하지 못한 상황에서도 예산 소진, 예정된 시간 경과, 시장 출시 압박 등의 이유로 테스트 활동을 조기에 마감하는 경우도 많다. 추가 테스팅 없이 출시하는 상황이라도 프로젝트 이해관계자와 비즈니스 책임자가 리스크를 검토하고 수용하면 테스트를 종료할 수 있다.

## 5.2.4 테스트 실행 일정 (Test Execution Schedule)
{: .notice--success}

<span style="color:green">(K3) 우선순위, 기술적 및 논리적 의존성 정보를 이용해 테스트 케이스 실행 일정을 수립할 수 있다.</span>

테스트 케이스와 테스트 프로시저를 작성하고(일부 프로시저는 가능하다면 자동화) 테스트 프로시저와 테스트 케이스를 조합해 테스트 스위트를 생성한 후 테스트 스위트의 순서를 정해 실행 일정을 만들 수 있다. 테스트 실행 일정에서 테스트 스위트를 어떤 순서로 실행할지 정의한다. 테스트 실행 일정을 만들 때는 우선순위, 종속 관계, 확인 테스트, 리그레션 테스트, 가장 효율적인 테스트 실행 순서 등을 고려해야 한다.<br>
이상적인 테스트 케이스 실행 순서는 가장 우선순위가 높은 테스트 케이스를 먼저 실행하는 것이다. 그러나 실제로 테스트 케이스 간에 종속 관계가 있거나 테스팅 대상의 기능 자체가 종속 관계라면 우선순위에 따라 실행하지 못할 수도 있다. 우선순위가 높은 테스트 케이스가 우선순위가 낮은 테스트 케이스에 종속되어 있다면 낮은 우선순위를 가진 테스트 케이스를 먼저 실행해야 한다.<br>
마찬가지로 테스트 케이스가 서로 종속 관계를 가지고 있다면 각자의 우선순위와 상관없이 필요에 따라 배치해야 한다. 확인 및 리그레션 테스트 역시 수정에 대한 피드백의 중요도에 따라 우선순위를 정해야 하고 이 경우에도 종속 관계를 적용할 수 있다.<br>
상황에 따라 테스트를 다양한 순서로 배치할 수 있으며 각 순서 배치에 따라 효율성 수준이 다를 수 있다. 이런 경우, 테스트 실행 효율성과 우선순위 준수 간의 절충을 고려한 결정이 필요하다.

## 5.2.5 테스트 노력에 영향을 미치는 요소 (Factors Influencing the Test Effort)
{: .notice--success}

<span style="color:green">(K1) 테스팅과 연관된 노력에 영향을 주는 요소를 식별할 수 있다.</span>

테스트 노력 추정은 테스트 관련 작업에 필요한 노력의 양을 예측하는 활동으로 이는 특정 프로젝트, 릴리스, 반복주기에서 테스팅의 목적을 충족하는 데 필요하다. 테스트 노력에 영향을 주는 요소는 아래와 같이 제품 특성, 개발 프로세스 특성, 관련 인물의 특성, 테스트 결과 등이 있다.

**제품 특성 (Product characteristics)**
- 제품과 관련된 리스크
- 테스트 베이시스의 품질
- 제품의 크기
- 제품 도메인의 복잡도
- 품질 특성 요구사항 (예: 보안성, 신뢰성)
- 요구되는 테스트 문서의 상세화 정도
- 법적, 규제 준수 요구사항

**개발 프로세스 특성 (Development process characteristics)**
- 조직의 안정성과 성숙도
- 사용하는 개발 모델
- 테스트 접근법
- 사용하는 도구
- 테스트 프로세스
- 시간적 압박

**인력 특성 (People characteristics)**
- 관련된 인원의 역량과 경험, 특히 유사한 프로젝트나 제품 관련 (예: 도메인 지식)
- 팀 응집력과 리더십

**테스트 결과 (Test results)**
- 발견한 결함 수와 심각도
- 필요한 재작업 규모

## 5.2.6 테스트 추정 기법 (Test Estimation Techniques)
{: .notice--success}

<span style="color:green">(K2) 메트릭 기반 추정 기법과 전문가 기반 추정 기법의 차이를 설명할 수 있다.</span>

충분한 테스팅을 하는 데 필요한 노력을 추정하는 예측 기법 몇 가지가 있다. 가장 많이 사용하는 두 가지 기법은 다음과 같다:
- 메트릭 기반 기법: 기존 유사한 프로젝트에서 얻은 메트릭에 기반하거나 보편적인 값을 바탕으로 테스트 노력 예측
- 전문가 기반 기법: 테스팅 작업의 책임자나 전문가의 경험을 기반으로 테스트 노력 예측

예를 들어, 애자일 개발의 번다운 차트(Burndown charts)를 메트릭 기반 접근법의 예로 볼 수 있는데, 이는 남아있는 노력을 파악하고 보고함으로써 팀이 다음 반복주기에서 할 수 있는 작업의 양을 산정하는 데 사용할 팀의 업무진행 속도를 계산할 수 있게 해주기 때문이다. 반면 플래닝 포커(Planning poker)는 전문가 기반 접근법의 예로, 팀원이 자신의 경험을 기반으로 특정 기능을 인도하는 데 드는 노력을 추정한다 (ISTQB-CTFL- AT).<br>
순차적 개발 프로젝트에서의 메트릭 기반 접근법의 예로는 결함 제거 모델(Defect Removal Models)을 들 수 있다. 결함의 양과 결함을 제거하는 데 드는 시간을 파악하고 보고해서 차후 비슷한 성격의 프로젝트를 추정하는 기준으로 사용한다. 와이드밴드 델파이(Wideband Delphi) 추정 기법은 전문가 기반 접근법의 예로, 전문가 집단의 경험을 기반으로 추정치를 제공한다 (ISTQB-CTAL-TM).

# 5.3 테스트 모니터링과 제어 (Test Monitoring and Control)
{: .notice--warning .text-center}

테스트 모니터링의 목적은 정보 수집 및 테스트 활동에 대한 피드백과 가시성 제공이다. 모니터링 대상 정보는 수동 혹은 자동으로 수집할 수 있고, 테스트 진행 상황을 평가하는 데 활용한다. 그리고 테스트 종료 조건(예: 제품 리스크 커버리지, 요구사항 커버리지, 인수 기준)을 만족하는지 또는 애자일 프로젝트에서 완료의 정의와 관련된 테스팅 작업을 만족하는지 측정하는 데 이용한다.

테스트 제어는 수집하고 보고된 정보와 메트릭의 결과로 취해진 수정 조치나 가이드를 의미한다. 수정 조치(활동)는 어떤 테스트 활동을 커버하거나 소프트웨어 수명주기 활동에 영향을 미칠 수 있다.<br>
테스트 제어 활동의 예는 다음과 같다:
- 식별한 리스크(예: 소프트웨어 인도 지연) 발생 시 테스트 우선순위의 변경
- 테스트 환경이나 기타 자원의 가용 여부에 따라 테스트 일정 변경
- 재작업으로 인해 테스트 항목이 시작 조건이나 종료 조건 만족하는지 재평가

## 5.3.1 테스팅에 사용하는 메트릭 (Metrics Used in Testing)
{: .notice--success}

<span style="color:green">(K1) 테스팅에 사용하는 메트릭을 상기할 수 있다.</span>

테스팅 활동 중이나 종료 시점에 아래와 같은 사항을 평가하기 위해 메트릭을 수집할 수 있다:
- 계획한 일정과 예산 대비 진행 상황
- 테스트 대상의 현재 품질
- 테스트 접근법의 타당성
- 목적 대비 테스트 활동의 효과

일반적인 테스트 메트릭은 다음과 같다:
- 계획 대비 테스트 케이스 준비 작업 완료율 (또는 계획 대비 테스트 케이스 작성률)
- 계획 대비 테스트 환경 준비 작업 완료율
- 테스트 케이스 실행률 (예: 수행한/수행하지 않은 테스트 케이스 수, 테스트 케이스 합격/불합격 수, 테스트 컨디션 합격/불합격 수)
- 결함 정보 (예: 결함 밀도, 발견한 결함, 수정한 결함, 실패율, 확인 테스트 결과)
- 요구사항 커버리지, 사용자 스토리 커버리지, 인수 기준 커버리지, 리스크 커버리지, 코드 커버리지
- 작업 완료, 자원 할당과 사용, 노력
- 다음 결함을 발견하면 얻는 이익 대비 비용이나 테스트를 계속 실행해 얻게 되는 이익 대비 비용 등을 포함하는 테스팅 비용

## 5.3.2 테스트 보고의 목적, 내용, 독자 (Purposes, Contents, and Audiences for Test Reports)
{: .notice--success}

<span style="color:green">(K2) 테스트 보고서의 목적, 내용, 독자를 요약할 수 있다.</span>

테스트 보고의 목적은 테스트 활동(예: 테스트 레벨) 중이나 마무리 시점의 테스트 활동 정보 요약과 공유이다. 테스트 활동 중 작성하는 테스트 보고서는 테스트 진행 상황 보고서, 테스트 활동 종료 시점에 작성하는 테스트 보고서는 테스트 요약 보고서라고 부르기도 한다.<br>
테스트 관리자는 테스트 모니터링과 제어 과정 중에 이해관계자에게 정기적으로 테스트 진행 상황을 보고한다. 테스트 진행 상황 보고서와 테스트 요약 보고서에 공통으로 들어가는 보고 내용 외에, 일반적인 테스트 진행 상황 보고서에 들어가는 정보는 아래와 같다:
- 테스트 계획 대비 테스트 활동과 진행 상황
- 진행을 방해하는 요소
- 다음 보고 기간에 진행하기로 계획한 테스팅
- 테스트 대상의 품질

종료 조건을 만족하면 테스트 관리자는 테스트 요약 보고서를 작성한다. 이 보고서에는 최근 테스트 진행 상황과 기타 관련 정보에 근거해 테스팅 수행 요약 정보를 기록한다.<br>
일반적인 테스트 요약 보고서는 다음과 같은 내용을 포함한다:
- 테스팅 수행 내용 요약
- 테스트 기간 도중에 발생한 상황 정보
- 계획 대비 편차 (예: 일정, 기간, 테스팅 활동 노력)
- 종료 조건 및 완료의 정의에 대한 테스팅 현황과 제품 품질
- 진행을 방해했거나 계속해서 방해하고 있는 요소
- 메트릭 (5.3.1 에서 설명한 결함, 테스트 케이스, 테스트 커버리지, 활동 진행 상황, 소비한 자원)
- 잔존 리스크 (5.5 절 참조)
- 재사용 가능한(만들어 낸) 테스트 작업 산출물

테스트 보고서의 내용은 프로젝트, 조직 요구사항, 소프트웨어 개발 수명주기에 따라 달라진다. 예를 들어 이해관계자나 규제가 많은 복잡한 프로젝트는 간단한 소프트웨어 업데이트 프로젝트보다 훨씬 상세하고 철저한 보고가 필요하다. 또 다른 예로, 애자일 개발에서 테스트 진행 상황 보고를 작업 보드, 결함 요약, 번다운 차트에 통합할 수 있고 일일 스탠드업(stand-up) 회의에서 공유할 수 있다 (ISTQB-CTFL-AT 참조).<br>
테스트 보고서는 프로젝트의 정황뿐 아니라 보고의 대상자에 따라서도 조정해야 한다. 기술적인 배경이 있거나 테스트팀을 대상으로 하는 보고서의 형식이나 내용은 경영층을 대상으로 하는 요약 보고서와 달라야 한다. 전자에서는 결함 유형과 추세에 대한 상세한 정보가 중요하고, 후자에서는 상위 수준으로 작성된 보고서(예: 우선순위별 결함 상태 요약, 예산, 일정, 테스트 컨디션별 합격/불합격/미실행 정보)가 더 적절할 수 있다.<br>
ISO 표준(ISO/IEC/IEEE 29119-3)은 테스트 진행 상황 보고서와 테스트 완료 보고서(본 실러버스는 테스트 요약 보고서라고 함), 두가지 형식의 보고서 내용 구성과 예제를 제공하고 있다.

# 5.4 형상 관리 (Configuration Management)
{: .notice--warning .text-center}

<span style="color:green">(K2) 형상 관리가 테스팅을 어떻게 지원하는지 요약할 수 있다.</span>

형상 관리의 목적은 프로젝트와 제품 수명주기 동안 컴포넌트나 시스템, 테스트웨어와 이들 서로간의 관계 통합을 수립하고 유지하는 데 있다.<br>
형상 관리는 테스팅을 적절히 지원하고자 아래 내용을 확인한다:
- 모든 테스트 항목에 고유 식별번호를 부여하고, 버전을 관리하고, 변경 이력을 기록한다. 형상 관리에서 테스트 항목은 서로 연관돼 있다.
- 모든 테스트웨어 항목에 고유 식별번호를 부여하고, 버전을 관리하고, 변경사항을 추적하고, 서로 연결해 테스트 항목 버전과도 연결되도록 해서 테스트 프로세스 전반에 걸쳐 추적성을 유지할 수 있게 한다.
- 식별한 모든 문서와 소프트웨어 아이템은 테스트 문서 내에서 명확하게 상호 참조되도록 한다.

테스트 계획을 수립하면서 형상관리 절차와 인프라(도구)를 식별하고 구현해야 한다.

# 5.5 리스크와 테스팅 (Risks and Testing)
{: .notice--warning .text-center}

## 5.5.1 리스크의 정의 (Definition of Risk)
{: .notice--success}

<span style="color:green">(K1) 장애 발생 가능성과 영향도를 이용해 리스크 수준을 정의할 수 있다.</span>

리스크란 미래에 부정적 결과를 가져오는 이벤트의 발생 가능성이다. 리스크 수준은 이벤트 발생 가능성과 이벤트로 인한 영향도(피해)로 결정한다.

## 5.5.2 제품 및 프로젝트 리스크 (Product and Project Risks)
{: .notice--success}

<span style="color:green">(K2) 프로젝트 리스크와 제품 리스크를 구별할 수 있다.</span>

제품 리스크는 작업 산출물(예: 명세, 컴포넌트, 시스템, 테스트 등)이 사용자나 이해관계자의 합당한 니즈를 충족하지 못할 가능성이다. 제품 리스크가 제품의 특정 품질 특성(예: 기능 안전성, 신뢰성, 성능 효율성, 사용성, 보안성, 호환성, 유지 보수성, 이식성)과 연관되는 경우 품질 리스크라고 한다.<br>
제품 리스크의 예는 다음과 같다:
- 소프트웨어가 명세에서 의도한 기능을 수행하지 못함
- 소프트웨어가 사용자, 고객이나 이해관계자가 요구하는 기능을 수행하지 못함
- 시스템 아키텍처가 일부 비기능 요구사항을 충분히 지원하지 못함
- 특정 계산식이 특정 상황에서 올바르게 수행되지 못함
- 루프(loop) 제어 구조 코딩이 잘못됨
- 고성능 거래 처리 시스템의 응답 시간이 적절하지 않음
- 사용자 경험(UX, User eXperience) 피드백이 제품 기대치에 미치지 못함

프로젝트 리스크는 발생하면 프로젝트 목적 달성 능력에 부정적인 영향을 줄 수 있는 상황이다.<br>
프로젝트 리스크의 예는 다음과 같다:
- 프로젝트 이슈:
  + 배포, 작업 완료, 종료 조건이나 완료의 정의를 만족하지 못하고 지연된다.
  + 부정확한 추정, 우선순위가 높은 프로젝트에 예산 재배정, 또는 조직 전반에 걸친 예산 삭감으로 예산이 부족할 수 있다.
  + 프로젝트 후반에 발생하는 변경은 상당한 재작업을 불러올 수 있다.
- 조직 이슈:
  + 역량, 교육, 인력이 부족할 수 있다.
  + 개인적인 문제로 갈등이나 문제가 생길 수 있다.
  + 사용자, 비즈니스 인력, 해당 분야 전문가들이 비즈니스 우선순위 마찰로 참여하지 못할 수 있다.
- 정치적 이슈:
  + 테스터가 필요한 사항이나 테스트 결과를 제대로 전달하지 못할 수 있다.
  + 개발자나 테스터가 테스팅과 리뷰 도중 발견한 사항에 대한 후속 조치를 못할 수 있다 (예를 들어, 개발 및 테스팅 프랙티스를 개선하지 못함).
  + 테스팅에 대한 잘못된 태도나 기대가 있을 수 있다 (예를 들어, 테스팅 도중 발견한 결함의 가치를 알아보지 못함).
- 기술적 이슈:
  + 요구사항이 충분히 잘 정의되지 않을 수 있다.
  + 기존 제약 사항으로 요구사항을 만족하지 못할 수 있다.
  + 테스트 환경이 필요한 시점에 준비되지 않을 수 있다.
  + 데이터 변환, 마이그레이션 계획 및 도구 지원이 필요한 시점에 제공되지 않을 수 있다.
  + 개발 프로세스의 약점은 프로젝트 작업 산출물 (예: 설계, 코드, 형상, 테스트 데이터, 테스트 케이스)의 품질이나 일관성에 영향을 줄 수 있다.
  + 결함 관리가 부실하고 기타 유사한 문제 때문에 축적된 결함이나 기타 기술적 부채를 가져올 수 있다.
- 공급자 이슈:
  + 외부 공급자가 필요한 제품이나 서비스를 공급하지 못하거나 파산할 수 있다.
  + 계약 관련 이슈로 프로젝트에 문제가 생길 수 있다.

프로젝트 리스크는 개발 활동과 테스트 활동 양쪽 모두에 영향을 미칠 수 있다. 프로젝트 관리자가 모든 프로젝트 리스크에 대한 책임을 지는 것이 일반적이지만, 테스트와 관련된 프로젝트 리스크는 테스트 관리자가 책임을 지는 경우도 있다.

## 5.5.3 리스크 기반 테스팅과 제품 품질 (Risk-based Testing and Product Quality)
{: .notice--success}

<span style="color:green">(K2) 제품 리스크 분석이 테스팅의 범위와 테스팅의 충분함에 어떻게 영향을 미치는지 예를 들어 설명할 수 있다.</span>

리스크는 테스팅 노력을 집중하는 데 사용된다. 리스크는 테스팅을 언제, 어디서 시작할지 결정하고 좀 더 관심을 가져야 할 영역을 식별하는 데 사용된다. 테스팅은 부정적인 이벤트의 발생 가능성을 줄이거나 부정적인 이벤트의 영향을 줄이기 위해 사용한다. 리스크 완화 활동으로써 테스팅은 식별한 리스크뿐 아니라 잔존(해결하지 못한) 리스크에 대한 정보도 제공한다.<br>
리스크 기반 접근법은 제품 리스크 수준을 조기에 낮추는 데 기여한다. 리스크 기반 테스팅은 제품 리스크 식별과 리스크 발생 가능성과 영향을 평가하는 제품 리스크 분석을 포함한다. 제품 리스크 정보로 얻은 결과는 테스트 계획, 명세, 테스트 케이스 준비와 실행, 테스트 모니터링에 사용한다. 초기에 제품 리스크를 평가하면 프로젝트 성공에 기여한다.<br>
리스크 기반 접근법에서 제품 리스크 분석 결과는 다음에 사용된다:
- 사용할 테스트 기법 결정
- 수행할 테스트 레벨과 유형 확정 (예: 보안성 테스팅, 가용성 테스팅)
- 테스트 수행 범위 결정
- 가능한 조기에 심각한 결함을 발견하기 위해 테스트 우선순위 결정
- 기존 테스팅 활동 외 리스크 완화를 위한 다른 활동의 식별 (예: 경험이 부족한 설계자에게 교육 제공)

리스크 기반 테스팅은 프로젝트 이해관계자의 집단 지식과 통찰력을 기반으로 제품 리스크를 분석한다. 제품 장애 발생 가능성을 최소화하기 위해 리스크 관리 활동은 다음과 같은 절차를 따르게 된다:
- 잘못될 수 있는 것(리스크)을 분석 (그리고 정기적으로 재분석)
- 처리해야 할 중요한 리스크가 무엇인지 판단
- 해당 리스크를 완화하기 위한 행동 구현
- 리스크의 실제 발생을 대비한 대책 수립

또 테스팅은 새로운 리스크를 식별하고 어떤 리스크를 완화해야 하는지 판단하는 데 도움을 주며 리스크에 대한 불확실성을 낮춰준다.

# 5.6 결함 관리 (Defect Management)
{: .notice--warning .text-center}

<span style="color:green">(K3) 테스팅하면서 식별한 결함을 결함 보고서로 작성할 수 있다.</span>

테스팅의 목적 중 하나가 결함을 찾는 것이기 때문에 테스팅 중 발견한 결함은 반드시 기록해야 한다. 결함을 기록하는 방법은 테스트 대상 컴포넌트나 시스템의 정황, 테스트 레벨, 소프트웨어 개발 수명주기 모델에 따라 달라진다. 찾아낸 모든 결함은 조사하고, 발견에서 결함 분류까지 추적해야 한다 (예: 결함 수정과 결함 해결에 대한 확인 테스팅 완료 여부, 다음 릴리스로 연기, 영구적인 제품 제약 사항으로 인정 등). 모든 결함을 해결까지 관리하기 위해 조직은 결함 관리 프로세스(워크플로우와 결함 분류 규칙)를 수립해야 한다. 아키텍처, 설계자, 개발자, 테스터, 제품 책임자 등 결함 관리에 참여하는 모든 사람이 프로세스에 동의해야 한다. 일부 조직에서는 결함 로깅(logging)과 추적이 매우 비공식적일 수 있다.<br>
결함 관리 프로세스를 수행하다 보면 일부 보고는 결함에 의한 실제 장애가 아닌 거짓양성으로 보고되기도 한다. 예를 들어 네트워크 연결이 끊기거나 시간 초과(time out)로 테스트 결과는 불합격이 될 수 있다. 이런 결과는 테스트 대상의 결함 때문이 아니라 이상 현상(anomaly) 때문일 수 있어 조사가 필요하다. 테스터는 결함으로 보고하는 거짓양성의 수를 최소화해야 한다.<br>
결함은 코드 작성 중, 정적 분석, 리뷰, 동적 테스팅 또는 소프트웨어 제품을 사용하는 중에 보고할 수 있다. 결함은 코드나 운영 중인 시스템이나 요구사항, 사용자 스토리와 인수 조건, 개발 문서, 테스트 문서, 사용자 매뉴얼, 설치 가이드 같은 문서에서 이슈로 보고할 수 있다. 효율적이고 효과적인 결함 관리 프로세스를 위해 조직은 결함의 속성, 분류, 워크플로우에 대한 표준을 정의해 놓을 수 있다.<br>
일반적인 결함 보고서의 목적은 다음과 같다:
- 발생한 모든 부정적인 이벤트 정보를 개발자와 기타 관계자에게 제공해 구체적인 영향을 식별하고, 재현 테스트로 문제를 격리하고, 잠재 결함을 수정하고, 필요에 따라서는 문제를 해결할 다른 방법을 찾을 수 있도록 한다.
- 테스트 관리자에게 작업 산출물의 품질과 테스팅 영향을 추적할 방법을 제공한다 (예: 많은 결함을 보고하면 테스터는 테스트를 수행하는 데 시간을 쓰는 대신에 결함 보고에 많은 시간을 할애하게 되고 필요한 확인 테스팅의 양도 많아진다).
- 개발과 테스트 프로세스 개선에 대한 아이디어를 제공한다.

동적 테스팅에서 작성하는 결함 보고서의 내용은 일반적으로 다음과 같다:
- 식별 번호
- 제목, 보고하는 결함에 대한 짧은 요약
- 결함 보고 날짜, 보고 주체 조직 및 작성자
- 테스트 항목 식별자(테스트 대상 형상 항목)와 환경
- 결함을 발견한 개발 수명주기 단계
- 로그, 데이터베이스 덤프, 스크린샷, 녹화 기록(테스트 실행 중 녹화했다면) 등의 결함 재현과 해결을 위한 설명
- 기대 및 실제 결과
- 이해관계자의 관점에서의 결함 영향도(심각도)의 범위와 정도
- 수정 우선순위 (긴급하게 처리해야 하는 순서)
- 결함 보고서의 상태 (예: 신규, 연기, 중복, 수정 대기, 확인 테스팅 대기, 재오픈, 완료)
- 결론, 의견, 승인 여부
- 글로벌 이슈 (예를 들어, 결함 수정의 결과로 영향을 받는 다른 영역)
- 변경 이력 (예를 들어, 프로젝트 팀원이 결함을 격리하고 복구하고, 수정 여부를 확인하는 데 취한 조치 순서)
- 참조 (문제를 발견하게 해 준 테스트 케이스 포함)

결함 관리 도구를 사용하면 위 정보 중 일부는 자동으로 작성될 수 있다 (예: 고유 식별번호 자동 부여, 결함 상태 자동 할당, 결함 보고 상태 자동 업데이트). 정적 테스팅, 특히 리뷰에서 발견하는 결함은 다양한 방법(예: 리뷰 회의록)으로 문서화한다.<br>
결함 보고서의 내용 관련 예제는 ISO 표준(ISO/IEC/IEEE 29119-3)을 참조한다. 해당 표준은 결함 보고서를 인시던트 보고서로 부른다.

# ● 용어
{: .notice .text-center}

<details>
<summary>Keywords</summary>
<div markdown="1">

- 형상 관리(configuration management)

- 결함 관리(defect management)

- 결함 리포트(defect report)

- 시작 조건(entry criteria)

- 종료 조건(exit criteria)

- 제품 리스크(product risk)

- 프로젝트 리스크(project risk)

- 리스크(risk)

- 리스크 수준(risk level)

- 리스크 기반 테스팅(risk-based testing)

- 테스트 접근법(test approach)

- 테스트 제어(test control)

- 테스트 추정(test estimation)

- 테스트 관리자(test manager)

- 테스트 모니터링(test monitoring)

- 테스트 계획서(test plan)

- 테스트 계획(test planning)

- 테스트 진행 보고서(test progress report)

- 테스트 전략(test strategy)

- 테스트 요약 보고서(test summary report)

- 테스터(tester)

</div>
</details>

# ● 샘플문제
{: .notice--danger .text-center}

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

---

<details>
<summary><span style="color:red">Answer</span></summary>
<div markdown="1">



</div>
</details>

# ● 자료참고
{: .notice--info .text-center}

[실러버스 본문](http://www.kstqb.org/board_skin/board_view.asp?idx=426&page=1&bbs_code=4&key=0&word=&etc=ISTQB){: .btn .btn--info}
[실러버스 용어](http://www.kstqb.org/board_skin/board_view.asp?idx=342&page=2&bbs_code=4&key=0&word=&etc=ISTQB){: .btn .btn--info}
[샘플문제](http://www.kstqb.org/board_skin/board_view.asp?idx=433&page=2&bbs_code=5&key=0&word=&etc=){: .btn .btn--info}